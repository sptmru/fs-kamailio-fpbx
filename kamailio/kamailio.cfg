#!KAMAILIO
#
# Kamailio SIP Server v5.5 - default configuration script
#     - web: https://www.kamailio.org
#     - git: https://github.com/kamailio/kamailio
#
# Direct your questions about this file to: <sr-users@lists.kamailio.org>
#
# Refer to the Core CookBook at https://www.kamailio.org/wiki/
# for an explanation of possible statements, functions and parameters.
#
# Note: the comments can be:
#     - lines starting with #, but not the pre-processor directives,
#       which start with #!, like #!define, #!ifdef, #!endif, #!else, #!trydef,
#       #!subst, #!substdef, ...
#     - lines starting with //
#     - blocks enclosed in between /* */
# Note: the config performs symmetric SIP signaling
#     - it sends the reply to the source address of the request
#     - remove the use of force_rport() for asymmetric SIP signaling
#
# Several features can be enabled using '#!define WITH_FEATURE' directives:
#
# *** To run in debug mode:
#     define WITH_DEBUG
#     - debug level increased to 3, logs still sent to syslog
#     - debugger module loaded with cfgtrace endabled
#
# *** To enable mysql:
#     - define WITH_MYSQL
# *** To enable PGSQL:
#!define WITH_PGSQL
#
# #!define WITH_HOMER
# *** To enable authentication execute:
#     - enable mysql
# - define WITH_AUTH
#     - add users using 'kamctl' or 'kamcli'
#
# *** To enable IP authentication execute:
#     - enable mysql
#     - enable authentication
#     - define WITH_IPAUTH
#     - add IP addresses with group id '1' to 'address' table
#
# *** To enable persistent user location execute:
#     - enable mysql
#     - define WITH_USRLOCDB
#
# *** To enable presence server execute:
#     - enable mysql
#     - define WITH_PRESENCE
#     - if modified headers or body in config must be used by presence handling:
#     - define WITH_MSGREBUILD
#
# *** To enable nat traversal execute:
#!define WITH_NAT
#     - option for NAT SIP OPTIONS keepalives: WITH_NATSIPPING
#     - install RTPProxy: http://www.rtpproxy.org
#     - start RTPProxy:
#        rtpproxy -l _your_public_ip_ -s udp:localhost:7722
#
# *** To use RTPEngine (instead of RTPProxy) for nat traversal execute:
#!define WITH_RTPENGINE
#     - install RTPEngine: https://github.com/sipwise/rtpengine
#     - start RTPEngine:
#        rtpengine --listen-ng=127.0.0.1:2223 ...
#
# *** To enable PSTN gateway routing execute:
#     - define WITH_PSTN
#     - set the value of pstn.gw_ip
#     - check route[PSTN] for regexp routing condition
#
# *** To enable database aliases lookup execute:
#     - enable mysql
#     - define WITH_ALIASDB
#
# *** To enable speed dial lookup execute:
#     - enable mysql
#     - define WITH_SPEEDDIAL
#
# *** To enable multi-domain support execute:
#     - enable mysql
#!define WITH_MULTIDOMAIN
#
# *** To enable TLS support execute:
#     - adjust CFGDIR/tls.cfg as needed
# #!define WITH_TLS
#
# *** To enable JSONRPC over HTTP(S) support execute:
#!define WITH_JSONRPC
#     - adjust event_route[xhttp:request] for access policy
#
# *** To enable anti-flood detection execute:
#     - adjust pike and htable=>ipban settings as needed (default is
#       block if more than 16 requests in 2 seconds and ban for 300 seconds)
#     - define WITH_ANTIFLOOD
#
# *** To block 3XX redirect replies execute:
#     - define WITH_BLOCK3XX
#
# *** To block 401 and 407 authentication replies execute:
#     - define WITH_BLOCK401407
#
# *** To enable VoiceMail routing execute:
#     - define WITH_VOICEMAIL
#     - set the value of voicemail.srv_ip
#     - adjust the value of voicemail.srv_port
#
# *** To enhance accounting execute:
#     - enable mysql
#     - define WITH_ACCDB
#     - add following columns to database
#!ifdef ACCDB_COMMENT
  ALTER TABLE acc ADD COLUMN src_user VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE acc ADD COLUMN src_domain VARCHAR(128) NOT NULL DEFAULT '';
  ALTER TABLE acc ADD COLUMN src_ip varchar(64) NOT NULL default '';
  ALTER TABLE acc ADD COLUMN dst_ouser VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE acc ADD COLUMN dst_user VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE acc ADD COLUMN dst_domain VARCHAR(128) NOT NULL DEFAULT '';
  ALTER TABLE missed_calls ADD COLUMN src_user VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE missed_calls ADD COLUMN src_domain VARCHAR(128) NOT NULL DEFAULT '';
  ALTER TABLE missed_calls ADD COLUMN src_ip varchar(64) NOT NULL default '';
  ALTER TABLE missed_calls ADD COLUMN dst_ouser VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE missed_calls ADD COLUMN dst_user VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE missed_calls ADD COLUMN dst_domain VARCHAR(128) NOT NULL DEFAULT '';
#!endif
#!define FLT_FS 10
#!define FLT_DID 11
#!define FLT_INV 12
#!define FLT_WS 13
####### Include Local Config If Exists #########
import_file "kamailio-local.cfg"

####### Defined Values #########

# *** Value defines - IDs used later in config
#!ifdef WITH_DEBUG
#!define DBGLEVEL 3
#!else
#!define DBGLEVEL 1
#!endif

#!ifdef WITH_MYSQL
# - database URL - used to connect to database server by modules such
#       as: auth_db, acc, usrloc, a.s.o.
#!trydef DBURL "mysql://kamailio:kamailiorw@localhost/kamailio"
#!endif

#!ifdef WITH_PGSQL
#!define DBURL "postgres://dbuser:slakn09adsfm2@postgres_kamailio:5432dd/kamailio"
#!endif

#!ifdef WITH_MULTIDOMAIN
# - the value for 'use_domain' parameters
#!define MULTIDOMAIN 1
#!else
#!define MULTIDOMAIN 0
#!endif

# - flags
#   FLT_ - per transaction (message) flags
#!define FLT_ACC 1
#!define FLT_ACCMISSED 2
#!define FLT_ACCFAILED 3
#!define FLT_NATS 5

#	FLB_ - per branch flags
#!define FLB_NATB 6
#!define FLB_NATSIPPING 7
# primary kamailio server
#!substdef "!NODE02!IP1!g" 
# failover secondary kamailio server
#!substdef "!NODE01!IP2!g"
#!substdef "!FloatIP!floatip!g"
#!substdef "!WEBSOCKETPORT!8443!g"
#!substdef "!KamailioAPI!2443!g"
#!substdef "!INCOMINGPORTRELAY!5070!g"
#!substdef "!InternalRTPEngine!10.18.0.32!g"
####### Global Parameters #########

/* LOG Levels: 3=DBG, 2=INFO, 1=NOTICE, 0=WARN, -1=ERR, ... */
debug=DBGLEVEL

/* set to 'yes' to print log messages to terminal or use '-E' cli option */
log_stderror=no

memdbg=5
memlog=5

mem_join=1
log_facility=LOG_LOCAL0
log_prefix="{$mt $hdr(CSeq) $ci} "

/* number of SIP routing processes for each UDP socket
 * - value inherited by tcp_children and sctp_children when not set explicitely */
children=8

/* uncomment the next line to disable TCP (default on) */
# disable_tcp=yes

/* number of SIP routing processes for all TCP/TLS sockets */
tcp_children=8

/* uncomment the next line to disable the auto discovery of local aliases
 * based on reverse DNS on IPs (default on) */
# auto_aliases=no

/* add local domain aliases - it can be set many times */
# alias="sip.mydomain.com"

/* listen sockets - if none set, Kamailio binds to all local IP addresses
 * - basic prototype (full prototype can be found in Wiki - Core Cookbook):
 *      listen=[proto]:[localip]:[lport] advertise [publicip]:[pport]
 * - it can be set many times to add more sockets to listen to */
listen=udp:10.1.0.200:5060 advertise 10.1.0.200:5060
listen=tls:10.1.0.200:WEBSOCKETPORT advertise 10.1.0.200:WEBSOCKETPORT
listen=tcp:10.1.0.200:5060 advertise 10.1.0.200:5060
listen=tls:10.1.0.200:KamailioAPI advertise 10.1.0.200:KamailioAPI
#!ifdef WITH_TLS
enable_tls=yes

/* upper limit for TLS connections */
tls_max_connections=2048
#!endif
#listen=eth0:5060
#listen=eth0:1:5060
tls_port_no = 5061

/* life time of TCP connection when there is no traffic
 * - a bit higher than registration expires to cope with UA behind NAT */
tcp_connection_lifetime=3605

/* upper limit for TCP connections (it includes the TLS connections) */
tcp_max_connections=8192

#!ifdef WITH_JSONRPC
tcp_accept_no_cl=yes
#!endif


/* set it to yes to enable sctp and load sctp.so module */
enable_sctp=no

####### Custom Parameters #########

/* These parameters can be modified runtime via RPC interface
 * - see the documentation of 'cfg_rpc' module.
 *
 * Format: group.id = value 'desc' description
 * Access: $sel(cfg_get.group.id) or @cfg_get.group.id */

#!ifdef WITH_PSTN
/* PSTN GW Routing
 *
 * - pstn.gw_ip: valid IP or hostname as string value, example:
 * pstn.gw_ip = "10.0.0.101" desc "My PSTN GW Address"
 *
 * - by default is empty to avoid misrouting */
pstn.gw_ip = "" desc "PSTN GW Address"
pstn.gw_port = "" desc "PSTN GW Port"
#!endif

#!ifdef WITH_VOICEMAIL
/* VoiceMail Routing on offline, busy or no answer
 *
 * - by default Voicemail server IP is empty to avoid misrouting */
voicemail.srv_ip = "" desc "VoiceMail IP Address"
voicemail.srv_port = "5060" desc "VoiceMail Port"
#!endif

####### Modules Section ########

/* set paths to location of modules */
# mpath="/usr/local/kamailio1/lib64/kamailio/modules/"

#!ifdef WITH_MYSQL
loadmodule "db_mysql.so"
#!endif

#!ifdef WITH_PGSQL
loadmodule "db_postgres.so"
loadmodule "sqlops.so"
#!endif

#!ifdef WITH_JSONRPC
loadmodule "xhttp.so"
#!endif
loadmodule "jsonrpcs.so"
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "usrloc.so"
loadmodule "registrar.so"
loadmodule "textops.so"
loadmodule "textopsx.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
loadmodule "acc.so"
loadmodule "counters.so"
loadmodule "auth.so"
loadmodule "msrp.so"
loadmodule "websocket.so"

#!ifdef WITH_AUTH
loadmodule "auth_db.so"
#!ifdef WITH_IPAUTH
loadmodule "permissions.so"
#!endif
#!endif

#!ifdef WITH_ALIASDB
loadmodule "alias_db.so"
#!endif

#!ifdef WITH_SPEEDDIAL
loadmodule "speeddial.so"
#!endif

#!ifdef WITH_MULTIDOMAIN
loadmodule "domain.so"
#!endif

#!ifdef WITH_PRESENCE
loadmodule "presence.so"
loadmodule "presence_xml.so"
#!endif

#!ifdef WITH_NAT
loadmodule "nathelper.so"
#!ifdef WITH_RTPENGINE
loadmodule "rtpengine.so"
#!else
loadmodule "rtpproxy.so"
#!endif
#!endif

#!ifdef WITH_TLS
loadmodule "tls.so"
#!endif

#!ifdef WITH_ANTIFLOOD
loadmodule "pike.so"
#!endif
loadmodule "htable.so"
#!ifdef WITH_DEBUG
loadmodule "debugger.so"
#!endif
loadmodule "dispatcher.so"
loadmodule "uac.so"
loadmodule "path.so"
loadmodule "exec.so"
#!ifdef WITH_HOMER
loadmodule "siptrace.so"
# check IP and port of your capture node
modparam("siptrace", "duplicate_uri", "sip:homerdomain:9060")
# Send from an IP
modparam("siptrace", "send_sock_addr", "sip:10.18.0.2:5000")
modparam("siptrace", "hep_mode_on", 1)
modparam("siptrace", "hep_version", 3)
modparam("siptrace", "trace_to_database", 0)
modparam("siptrace", "trace_flag", 22)
modparam("siptrace", "trace_on", 1)
modparam("siptrace", "hep_capture_id", 997)
modparam("siptrace", "send_sock_name", "HOMER7")
#!endif
# ----------------- setting module-specific parameters ---------------
modparam("websocket", "keepalive_mechanism", 0)
modparam("websocket", "keepalive_timeout", 180)
modparam("websocket", "sub_protocols", 1)
#modparam("uac","restore_mode","auto")
#modparam("rr", "append_fromtag", 1)
#modparam("dispatcher", "list_file", "/usr/local/kamailio1/etc/kamailio/dispatcher.list")
modparam("dispatcher", "db_url", DBURL)
modparam("dispatcher", "flags", 2)
modparam("dispatcher", "ds_probing_mode", 3)
modparam("dispatcher", "ds_probing_threshold", 9)
modparam("dispatcher", "ds_ping_method", "OPTIONS")
modparam("dispatcher", "ds_ping_from", "sip:sbc@floatdomain.com")
modparam("dispatcher", "ds_ping_interval", 10)
modparam("dispatcher", "ds_inactive_threshold", 5)
#modparam("dispatcher", "ds_default_socket", "udp:10.18.0.32:5060")
modparam("sqlops","sqlcon","pgc=>postgres://dbuser:slakn09adsfm2@postgres_kamailio:5432/kamailio")
modparam("db_postgres", "retries", 3)

# ----- jsonrpcs params -----
modparam("jsonrpcs", "pretty_format", 1)
/* set the path to RPC fifo control file */
# modparam("jsonrpcs", "fifo_name", "/run/kamailio/kamailio_rpc.fifo")
/* set the path to RPC unix socket control file */
# modparam("jsonrpcs", "dgram_socket", "/run/kamailio/kamailio_rpc.sock")
#!ifdef WITH_JSONRPC
modparam("jsonrpcs", "transport", 7)
#!endif

# ----- ctl params -----
/* set the path to RPC unix socket control file */
# modparam("ctl", "binrpc", "unix:/run/kamailio/kamailio_ctl")

# ----- sanity params -----
modparam("sanity", "autodrop", 0)

# ----- tm params -----
# auto-discard branches from previous serial forking leg
modparam("tm", "failure_reply_mode", 3)
# default retransmission timeout: 30sec
modparam("tm", "fr_timer", 30000) // default 30s
#modparam("tm", "fr_timer", 12000)
# default invite retransmission timeout after 1xx: 120sec
modparam("tm", "fr_inv_timer", 120000)
#modparam("tm", "retr_timer1", 1000) Oren Tests
#modparam("tm", "retr_timer2", 4000) Oren tests

# ----- rr params -----
# set next param to 1 to add value to ;lr param (helps with some UAs)
modparam("rr", "enable_full_lr", 0)
# do not append from tag to the RR (no need for this script)
modparam("rr", "append_fromtag", 1)
modparam("rr", "enable_double_rr", 0)

# ----- registrar params -----
modparam("registrar", "method_filtering", 1)
/* uncomment the next line to disable parallel forking via location */
# modparam("registrar", "append_branches", 0)
/* uncomment the next line not to allow more than 10 contacts per AOR */
# modparam("registrar", "max_contacts", 10)
/* max value for expires of registrations */
modparam("registrar", "max_expires", 3600)
/* set it to 1 to enable GRUU */
modparam("registrar", "gruu_enabled", 0)
/* set it to 0 to disable Path handling */
modparam("registrar", "use_path", 1)
/* save Path even if not listed in Supported header */
modparam("registrar", "path_mode", 0)

# ----- acc params -----
/* what special events should be accounted ? */
modparam("acc", "early_media", 0)
modparam("acc", "report_ack", 0)
modparam("acc", "report_cancels", 0)
/* by default ww do not adjust the direct of the sequential requests.
 * if you enable this parameter, be sure the enable "append_fromtag"
 * in "rr" module */
modparam("acc", "detect_direction", 0)
/* account triggers (flags) */
modparam("acc", "log_flag", FLT_ACC)
modparam("acc", "log_missed_flag", FLT_ACCMISSED)
modparam("acc", "log_extra",
	"src_user=$fU;src_domain=$fd;src_ip=$si;"
	"dst_ouser=$tU;dst_user=$rU;dst_domain=$rd")
modparam("acc", "failed_transaction_flag", FLT_ACCFAILED)
/* enhanced DB accounting */
#!ifdef WITH_ACCDB
modparam("acc", "db_flag", FLT_ACC)
modparam("acc", "db_missed_flag", FLT_ACCMISSED)
modparam("acc", "db_url", DBURL)
modparam("acc", "db_extra",
	"src_user=$fU;src_domain=$fd;src_ip=$si;"
	"dst_ouser=$tU;dst_user=$rU;dst_domain=$rd")
#!endif

# ----- usrloc params -----
modparam("usrloc", "timer_interval", 60)
modparam("usrloc", "timer_procs", 1)
modparam("usrloc", "use_domain", MULTIDOMAIN)
/* enable DB persistency for location entries */
#!ifdef WITH_USRLOCDB
modparam("usrloc", "db_url", DBURL)
modparam("usrloc", "db_mode", 2)
#!endif

# ----- auth_db params -----
#!ifdef WITH_AUTH
modparam("auth_db", "db_url", DBURL)
modparam("auth_db", "calculate_ha1", yes)
modparam("auth_db", "password_column", "password")
modparam("auth_db", "load_credentials", "")
modparam("auth_db", "use_domain", MULTIDOMAIN)

# ----- permissions params -----
#!ifdef WITH_IPAUTH
modparam("permissions", "db_url", DBURL)
modparam("permissions", "load_backends", 1)
#!endif

#!endif

# ----- alias_db params -----
#!ifdef WITH_ALIASDB
modparam("alias_db", "db_url", DBURL)
modparam("alias_db", "use_domain", MULTIDOMAIN)
#!endif

# ----- speeddial params -----
#!ifdef WITH_SPEEDDIAL
modparam("speeddial", "db_url", DBURL)
modparam("speeddial", "use_domain", MULTIDOMAIN)
#!endif

# ----- domain params -----
#!ifdef WITH_MULTIDOMAIN
modparam("domain", "db_url", DBURL)
modparam("domain", "domain_table", "omni_domains")
modparam("domain", "domain_attrs_table", "omni_domains_view")
modparam("domain", "did_col", "domain")
/* register callback to match myself condition with domains list */
modparam("domain", "register_myself", 0)
#!endif

#!ifdef WITH_PRESENCE
# ----- presence params -----
modparam("presence", "db_url", DBURL)

# ----- presence_xml params -----
modparam("presence_xml", "db_url", DBURL)
modparam("presence_xml", "force_active", 1)
#!endif

#!ifdef WITH_NAT
#!ifdef WITH_RTPENGINE
# ----- rtpengine params -----
#modparam("rtpengine", "rtpengine_sock", "udp:127.0.0.1:2223")
modparam("rtpengine", "db_url", DBURL)
modparam("rtpengine", "setid_default", 0)
modparam("rtpengine", "rtpengine_disable_tout", 120)
#!else
# ----- rtpproxy params -----
modparam("rtpproxy", "rtpproxy_sock", "udp:10.18.0.32:7722")
modparam("rtpproxy", "nortpproxy_str", "a=sdpmangled:yes\r\n")
#!endif
# ----- nathelper params -----
modparam("nathelper", "natping_interval", 30)
modparam("nathelper", "ping_nated_only", 1)
modparam("nathelper", "sipping_bflag", FLB_NATSIPPING)
modparam("nathelper", "sipping_from", "sip:pinger@kamailio.org")

# params needed for NAT traversal in other modules
modparam("nathelper|registrar", "received_avp", "$avp(RECEIVED)")
modparam("usrloc", "nat_bflag", FLB_NATB)
#!endif

#!ifdef WITH_TLS
# ----- tls params -----
modparam("tls", "config", "/usr/local/kamailio-1/etc/kamailio/tls.cfg")
modparam("tls", "tls_debug", 10)
#!endif

#!ifdef WITH_ANTIFLOOD
# ----- pike params -----
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 16)
modparam("pike", "remove_latency", 4)

# ----- htable params -----
/* ip ban htable with autoexpire after 5 minutes */
modparam("htable", "htable", "ipban=>size=8;autoexpire=300;")
#!endif

#!ifdef WITH_DEBUG
# ----- debugger params -----
modparam("debugger", "cfgtrace", 1)
modparam("debugger", "log_level_name", "exec")
#!endif

#htable module setting. vtp keeps transaction details.
modparam("htable", "htable", "vtp=>size=10;autoexpire=120;")
####### Routing Logic ########


/* Main SIP request routing logic
 * - processing of any incoming SIP request starts with this route
 * - note: this is the same as route { ... } */
request_route {
	###xlog("L_INFO", " packet recevied request from (IP:$si:$sp)\n");
	 # allow pings from other node
	if (is_method("OPTIONS") && ($si == "NODE01" || $si == "NODE02")) {
		options_reply();
	}
	# calls to inbound number from DID media incoming - omniservers
	if(ds_is_from_list("1")) {
		setflag(FLT_DID);
		if (is_method("INVITE")){
			xlog("L_NOTICE", "Incoming call [FullIP=$si:$sp Type=$rm CLID=$fU DID=$tU Domain=$td Host=$si]\n");
		}
	}
        # check if goes to ws
        if (nat_uac_test("64") || search_hf("Route", "transport=ws", "a") || search_hf("To", "transport=ws", "a")){
                setflag(FLT_WS);
#		xlog("L_NOTICE", "Recognize ws connection FullIP=$si:$sp Type=$rm CLID=$fU DID=$tU Domain=$td Host=$si]\n");
        }
	# per request initial checks

#!ifdef WITH_HOMER
        setflag(22);

        #start duplication mode: m or M for message; t or T for transaction; d or D for dialog
        sip_trace_mode("t");

        # send to 10.0.0.3 and assign a callid as correlation param
        sip_trace("sip:64.176.162.187:9060", "$ci-abc");

        #Send HEPLog:
        hlog("$hdr(P-MyID)", "Another one with a custom correlation ID");

#!endif

	route(REQINIT);

	# Mark the calls from Freeswitch/PBX servers to kamailio proxy
	if(ds_is_from_list("2")) {
		if (is_method("INVITE")){
			xlog("L_NOTICE", "From Freeswitch/Internal [FullIP=$si:$sp Type=$rm CLID=$fU Extension=$tU ExtIP=$td Domain=$fd Host=$si]\n");
		}
		setflag(FLT_FS);
	}

	# NAT detection
	route(NATDETECT);

	#Authentication
	#route(AUTH);
	route(REGISTRAR);

	# CANCEL processing
	if (is_method("CANCEL")) {
		if ($ru =~"pn_tok"){
			$sht(vtp=>id_index::$rU::$fd) = $null;
			$sht(vtp=>id_label::$rU::$fd) = $null;
		}
		if (t_check_trans()) {
			route(RELAY);
		}
		exit;
	}

	# handle retransmissions
	if (!is_method("ACK")) {
		if(t_precheck_trans()) {
			t_check_trans();
			exit;
		}
		t_check_trans();
	}

	# handle requests within SIP dialogs
	route(WITHINDLG);

	### only initial requests (no To tag)


	# record routing for dialog forming requests (in case they are routed)
	# - remove preloaded route headers
	remove_hf("Route");
	if (is_method("INVITE|SUBSCRIBE")) {
		record_route();
	}

	if (isflagset(FLT_FS)) {
		if ((is_method("INVITE")) && (!has_totag()) && ($ru =~"pn_tok")){
			if ($sht(vtp=>id_index::$rU::$fd) != $null) {
				send_reply("480", "Temporarily Unavailable");
				exit;
			}
			send_reply("100", "Suspending");
			xlog("L_INFO","[SUSPEND] Entered suspend mode\n");
			if ( !t_suspend() ) {
				xlog("L_NOTICE","[SUSPEND]  failed suspending trasaction [$T(id_index):$T(id_label)]\n");
				send_reply("501", "Suspending error");
				exit;
			}else{
				xlog("L_NOTICE","[SUSPEND]  suspended transaction [$T(id_index):$T(id_label)] $fU=> $rU add to rU fd=$fd or td=$td\n");
				$sht(vtp=>id_index::$rU::$fd) = $T(id_index);
				$sht(vtp=>id_label::$rU::$fd) = $T(id_label);
				xlog("L_NOTICE","[SUSPEND] htable key value [$sht(vtp=>id_index::$rU::$fd)   --   $sht(vtp=>id_label::$rU::$fd)]\n");
				route(SENDPUSH);
				exit;
			}
		}else{
			route(FROM_FS);
			exit;
		}
	}

	# account only INVITEs
	if (is_method("INVITE")) {
		setflag(FLT_ACC); # do accounting
	}

	# dispatch requests to foreign domains
	
	route(DISPATCH);

	### requests for my local domains

	# handle presence related requests
	#route(PRESENCE);

	# handle registrations

	if ($rU==$null) {
		# request with no Username in RURI
		sl_send_reply("484","Address Incomplete");
		exit;
	}

	# dispatch destinations to PSTN
	#route(PSTN);

	# user location service
	#route(LOCATION);
}
route[1] 
{

	# !! Nathelper
	if (uri=~"[@:](192\.168\.|10\.|172\.(1[6-9]|2[0-9]|3[0-1])\.)" && !search("^Route:")){
		sl_send_reply("479", "We don't forward to private IP addresses");
		exit;
	};

	# if client or server know to be behind a NAT, enable relay
	
        if (has_body("application/sdp")) {
                if (isflagset(FLT_WS)){
                        rtpengine_manage("UDP/TLS/TCP/RTP/SAVPF replace-origin replace-session-connection rtcp-mux-offer generate-mid DTLS=passive SDES-off ICE=force-relay trust-address");
                }else{
                        rtpengine_manage("RTP/AVP replace-origin replace-session-connection rtcp-mux-demux DTLS=off SDES-off ICE=remove trust-address");
                }
        }	# NAT processing of replies; apply to all transactions (for example,
	# re-INVITEs from public to private UA are hard to identify as
	# NATed at the moment of request processing); look at replies
	if (FLT_WS) {
		t_on_reply("PNTOK");
	}else{
		t_on_reply("1");
	}

	# send it out now; use stateful forwarding as it works reliably
	# even for UDP2TCP
	if (!t_relay()) {
		sl_reply_error();
	};
}


route[FROM_FS]
{
        route(RELAY);
        exit;
}
# Wrapper for relaying requests
route[RELAY] 
{
	# enable additional event routes for forwarded requests
	# - serial forking, RTP relaying handling, a.s.o.
	if (is_method("INVITE|BYE|SUBSCRIBE|UPDATE")) {
		if(!t_is_set("branch_route")) t_on_branch("MANAGE_BRANCH");
	}
	if (is_method("INVITE|SUBSCRIBE|UPDATE")) {
		if(!t_is_set("onreply_route")) t_on_reply("MANAGE_REPLY");
	}
	if (is_method("INVITE")) {
		if(!t_is_set("failure_route")) t_on_failure("MANAGE_FAILURE");
	}
	route(1);
}

route[SENDPUSH] {
	# if ($(ru{param.value,platform_id}) != "ios" ){
		# exec_avp("sudo python3.9 /usr/local/kamailio-1/etc/kamailio/pushAndroid.py '$rU' '$(ru{param.value,pn_tok})' '$fU' '$ci'", "$avp(result)");
	# }else{
		# exec_avp("sudo python3.9 /usr/local/kamailio-1/etc/kamailio/pushIOS.py '$rU' '$(ru{param.value,pnv_tok})' '$fU' '$ci'", "$avp(result)");
	# }
	sl_send_reply("100", "Pushing");
}

route[JOIN] {
	xlog("L_NOTICE","[JOIN] htable key value [$sht(vtp=>id_index::$tU::$fd)   --   $sht(vtp=>id_label::$tU::$fd)] \n");
	force_rport();
	fix_nated_register();
	$sht(vtp=>contact::$tU::$fd) = $(hdr(Contact){s.select,0,>}{re.subst,/u[0-9]{9}\.ocil\.omnitelecom\.com:8443/$si:$sp/g});
	$sht(vtp=>host::$tU::$fd) = $si + ":" + $sp;
	xlog("L_NOTICE","vtp=>host::$tU::$fd = $sht(vtp=>host::$tU::$fd) \n");
	t_continue("$sht(vtp=>id_index::$tU::$fd)", "$sht(vtp=>id_label::$tU::$fd)", "RESUME");
}

route[RESUME] {
	xlog("L_NOTICE","[RESUME] rm=$rm ru=$ru du=$du \n");
	$sht(vtp=>id_index::$rU::$fd) = $null;
	$sht(vtp=>id_label::$rU::$fd) = $null;
	setflag(FLT_WS);
	setflag(FLT_FS);
	uac_replace_to("$(sht(vtp=>contact::$rU::$fd){s.substr,1,0})");
	lookup("location");
	$var(x) = $(ru{s.select,0,;}{s.select,1,@});
	$ru=$(ru{s.replace,$var(x),$sht(vtp=>host::$rU::$fd)});
	route(RELAY);
	exit;
}

# Per SIP request initial checks
route[REQINIT] 
{
	# no connect for sending replies
	set_reply_no_connect();
	# enforce symmetric signaling
	# - send back replies to the source address of request
	force_rport();

#!ifdef WITH_ANTIFLOOD
	# flood detection from same IP and traffic ban for a while
	# be sure you exclude checking trusted peers, such as pstn gateways
	# - local host excluded (e.g., loop to self)
	if(src_ip!=myself) {
		if($sht(ipban=>$si)!=$null) {
			# ip is already blocked
			###xlog("request from blocked IP - $rm from $fu (IP:$si:$sp)\n");
			exit;
		}
		if (!pike_check_req()) {
			###xlog("L_ALERT","ALERT: pike blocking $rm from $fu (IP:$si:$sp)\n");
			$sht(ipban=>$si) = 1;33
			exit;
		}
	}
#!endif
	if($ua =~ "friendly|scanner|sipcli|sipvicious|VaxSIPUserAgent") {
		# silent drop for scanners - uncomment next line if want to reply
		# sl_send_reply("200", "OK");
		exit;
	}

	if (!mf_process_maxfwd_header("10")) {
		sl_send_reply("483","Too Many Hops");
		exit;
	}

	if(is_method("OPTIONS") && uri==myself && $rU==$null) {
		sl_send_reply("200","Keepalive");
		exit;
	}

	if(!sanity_check("17895", "7")) {
		xlog("Malformed SIP request from $si:$sp\n");
		exit;
	}
}

# Handle requests within SIP dialogs
route[WITHINDLG] 
{
	if (!has_totag()) return;
	
	# sequential request withing a dialog should
	# take the path determined by record-routing
	if (loose_route()) {
		route(DLGURI);
		if (is_method("BYE")) {
			setflag(FLT_ACC); # do accounting ...
			setflag(FLT_ACCFAILED); # ... even if the transaction fails
		} else if ( is_method("ACK") ) {
			# ACK is forwarded statelessly
			route(NATMANAGE);
		} else if ( is_method("NOTIFY") ) {
			# Add Record-Route for in-dialog NOTIFY as per RFC 6665.
			record_route();
		}
		route(RELAY);
		exit;
	}

	if (is_method("SUBSCRIBE") && uri == myself) {
		# in-dialog subscribe requests
		route(PRESENCE);
		exit;
	}
	if ( is_method("ACK") ) {
		if ( t_check_trans() ) {
			# no loose-route, but stateful ACK;
			# must be an ACK after a 487
			# or e.g. 404 from upstream server
			route(RELAY);
			exit;
		} else {
			# ACK without matching transaction ... ignore and discard
			exit;
		}
	}
	if (isflagset(FLT_FS) && is_method("NOTIFY")) return;
	sl_send_reply("404","Not here");
	exit;
}

route[REGISTRAR] {
	if(!is_method("REGISTER"))
		return;
	if (isflagset(FLT_WS)){
		save("location", "15");
		if ((($hdr(Expires) != "0") || !($hdr(Contact) =~ "expires=0")) && ($sht(vtp=>id_index::$tU::$fd) != $null) && $(hdr(Contact){param.value,pn_tok}) != $null ) {
			xlog("L_INFO", "New $rm ru=$ru tu=$tU \n");
			route(JOIN);
		}
		force_rport();
		fix_nated_register();
		append_hf("Path: <sip:FloatIP:5060;lr;received=sip:$si:$sp%3Btransport%3Dudp>\r\n");
	}else{
		add_path_received();
	}
	xlog("L_NOTICE", "Registration attempt [FullIP=$si:$sp Type=$rm Extension=$tU Domain=$td Host=$si]\n");
	route(DISPATCH);
}

# Dispatch requests
route[DISPATCH]
{	
	###xlog("L_NOTICE", "--- SCRIPT:received message protocol <$pr> <$td>\n");
	if ($td =~ "[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}") {
		xlog("L_WARN", "Attempt for direct IP instead of domain [FullIP=$si:$sp Type=$rm Extension=$tU Domain=$td Host=$si]\n");
		send_reply("404", "No destination");
		exit;
	}
	if ($td =~ "(u[0-9]{9}\.ocil\.omnitelecom\.com)$") {
		if (lookup_domain("$td", "to_")) {
			if(!ds_select_dst("$avp(to_setid)", "8", "2")) {
				send_reply("404", "No destination");
				xlog("L_WARN", "No active server for domain $td [FullIP=$si:$sp Type=$rm Extension=$tU Domain=$td Host=$si]\n");
				exit;
			}
		} else {
			send_reply("404", "No destination");
			xlog("L_WARN", "No domain in dispatch list [FullIP=$si:$sp Type=$rm Extension=$tU Domain=$td Host=$si]\n");
			exit;
		}
	} else {
		xlog("L_WARN", "Domain not in right format [FullIP=$si:$sp Type=$rm Extension=$tU Domain=$td Host=$si]\n");
		send_reply("404", "No destination");
		exit;
	}

	if (!isflagset(FLT_DID) && !isflagset(FLT_FS) && !isflagset(FLT_INV) && isflagset(FLT_ACC)) {
		setflag(FLT_INV);
		xlog("L_NOTICE", "Extension invite [FullIP=$si:$sp Type=$rm DID=$tU Extension=$fU Domain=$fd \n");
	}

	if (isflagset(FLT_DID)) {			
		$var(port)="5070;transport=UDP";			
	} else if ($pr == "tls") {			
		$var(port)="5061;transport=TLS";
	} else if ($pr == "tcp") {			
		$var(port)="5060;transport=TCP";
	} else {		
		$var(port)="5060;transport=UDP";
	}

	$du = $du+":"+$var(port);

	###xlog("L_NOTICE", "--- SCRIPT: Destination going to <$du>\n");
	t_on_failure("RTF_DISPATCH");
	route(1);
	exit;
}

# Try next destionations in failure route
failure_route[RTF_DISPATCH] {
	###xlog("L_NOTICE", "--- SCRIPT: In failure_route retrying another server for domain $fd\n");
	if (t_is_canceled()) {
		exit;
	}
	$var(failLog) = "";
	if (t_check_status("408") or (t_branch_timeout() and !t_branch_replied())) {
		if (t_check_status("408")){
			$var(failLog) = "Status 408 true ";
		}
		if (t_branch_timeout() and !t_branch_replied()){
			$var(failLog) = $var(failLog)+"t_branch_timeout and !t_branch_replied ";
		}
#		ds_mark_dst("t");
		$var(server_ip) = $(du{s.select,1,:});
		$var(server_ip) = "sip:"+$var(server_ip);
		$var(port) = $(du{s.select,2,:});
		xlog("L_WARN", "Failure in communication to server $var(server_ip) because '$var(failLog)' [FullIP=$si:$sp Type=$rm Extension=$tU Domain=$td Host=$si]\n");

############################
		if (lookup_domain("$td", "to_")) {
			if(!ds_select_dst("$avp(to_setid)", "8")) {
				xlog("L_WARN", "Backup server is down!!!!!, server $var(server_ip) [FullIP=$si:$sp Type=$rm Extension=$tU Domain=$td Host=$si]\n");
				send_reply("408", "Temporarily Unavailable");
				exit;
			}
			if ($du != $var(server_ip)) {
				xlog("L_WARN", "Change to backup server $du [FullIP=$si:$sp Type=$rm Extension=$tU Domain=$td Host=$si]\n");
			} else {
				xlog("L_NOTICE","Attempting to go to to same server $du [FullIP=$si:$sp Type=$rm Extension=$tU Domain=$td Host=$si]\n");
			}
			$du = $du+$var(port);
			t_on_failure("RTF_DISPATCH");
			route(1);
			exit;
		}
###########################
	}
	if (t_check_status("403")) {
		xlog("L_WARN", "No such extension or wrong password [FullIP=$si:$sp Type=$rm Extension=$tU Domain=$td Host=$si]\n");
	}			
}

onreply_route[1] {
     # NATed transaction ?
	if !t_check_status("(302)"){
		fix_nated_contact();
		subst_hf("Contact","/expires=[0-9]*/expires=80/","a");
		subst_hf("Path","/sip.*=(.*)/\1>/","a");
#subst_hf("Path","/sip.*=(sip[0-9:.]*).*/\1>/","a");
	}
	# fix_nated_sdp("6");
	if (has_body("application/sdp")) {
			rtpengine_manage("RTP/AVP");
			#rtpengine_manage("RTP/AVP replace-origin replace-session-connection");
	}   
 }

onreply_route[PNTOK]{
	fix_nated_contact();
	subst_hf("Path","/sip.*=(.*)/\1>/","a");
	if (has_body("application/sdp")) {
		rtpengine_manage();
	}
}
# User location service
route[LOCATION] {

#!ifdef WITH_SPEEDDIAL
	# search for short dialing - 2-digit extension
	if($rU=~"^[0-9][0-9]$") {
		if(sd_lookup("speed_dial")) {
			route(SIPOUT);
		}
	}
#!endif

#!ifdef WITH_ALIASDB
	# search in DB-based aliases
	if(alias_db_lookup("dbaliases")) {
		route(SIPOUT);
	}
#!endif

	$avp(oexten) = $rU;
	if (!lookup("location")) {
		$var(rc) = $rc;
		route(TOVOICEMAIL);
		t_newtran();
		switch ($var(rc)) {
			case -1:
			case -3:
				send_reply("404", "Not Found");
				exit;
			case -2:
				send_reply("405", "Method Not Allowed");
				exit;
		}
	}

	# when routing via usrloc, log the missed calls also
	if (is_method("INVITE")) {
		setflag(FLT_ACCMISSED);
	}

	route(RELAY);
	exit;
}

# Presence server processing
route[PRESENCE] {
	if(!is_method("PUBLISH|SUBSCRIBE")) return;

	if(is_method("SUBSCRIBE") && $hdr(Event)=="message-summary") {
		route(TOVOICEMAIL);
		# returns here if no voicemail server is configured
		sl_send_reply("404", "No voicemail service");
		exit;
	}

#!ifdef WITH_PRESENCE
#!ifdef WITH_MSGREBUILD
	# apply changes in case the request headers or body were modified
	msg_apply_changes();
#!endif
	if (!t_newtran()) {
		sl_reply_error();
		exit;
	}

	if(is_method("PUBLISH")) {
		handle_publish();
		t_release();
	} else if(is_method("SUBSCRIBE")) {
		handle_subscribe();
		t_release();
	}
	exit;
#!endif

	# if presence enabled, this part will not be executed
	if (is_method("PUBLISH") || $rU==$null) {
		sl_send_reply("404", "Not here");
		exit;
	}
	return;
}

# IP authorization and user authentication
route[AUTH] {
		if(is_present_hf("Authorization")){
                ###xlog ("L_DEBUG", "found XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX");
		return;	
		}
                ###xlog ("L_DEBUG", "In $hdr(Authorization) AUTH@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@2");
		auth_challenge("$fd", "0");
		exit;
#!ifdef WITH_AUTH

#!ifdef WITH_IPAUTH
	if((!is_method("REGISTER")) && allow_source_address()) {
		# source IP allowed
		return;
	}
#!endif

	if (is_method("REGISTER") ){#|| from_uri==myself) {
		# authenticate requests
		if (!auth_check("$fd", "subscriber", "1")) {
			auth_challenge("$fd", "0");
			exit;
		}
		# user authenticated - remove auth header
		if(!is_method("REGISTER|PUBLISH"))
			consume_credentials();
	}
	# if caller is not local subscriber, then check if it calls
	# a local destination, otherwise deny, not an open relay here
	if (from_uri!=myself && uri!=myself) {
		sl_send_reply("403","Not relaying");
		exit;
	}

#!else

	# authentication not enabled - do not relay at all to foreign networks
	if(uri!=myself) {
		sl_send_reply("403","Not relaying");
		exit;
	}

#!endif
	return;
}

# Caller NAT detection
route[NATDETECT] {
#!ifdef WITH_NAT
##Before websocket it was 63
	if (nat_uac_test("19")) {
		if (is_method("REGISTER") || !is_present_hf("Record-Route"))  {
			fix_nated_contact(); # Rewrite contact with source IP of signalling
			if ( is_method("INVITE") ) {			
				setbflag(6);
			}
		} else {
			if(is_first_hop()) {
				set_contact_alias();
			}
		}
		setflag(FLT_NATS);
	}
#!endif
	return;
}

# RTPProxy control and signaling updates for NAT traversal
route[NATMANAGE] {
#!ifdef WITH_NAT
	if (is_request()) {
		if(has_totag()) {
			#fix_nated_sdp("2"); # Add direction=active to SDP
			if(check_route_param("nat=yes")) {
				setbflag(FLB_NATB);
			}
		}
	}
	if (!(isflagset(FLT_NATS) || isbflagset(FLB_NATB))) return;

#!ifdef WITH_RTPENGINE
	if(nat_uac_test("8")) {
		rtpengine_manage("SIP-source-address replace-origin replace-session-connection");
	} else {
		rtpengine_manage("replace-origin replace-session-connection");
	}
#!else
	if(nat_uac_test("8")) {
		rtpproxy_manage("co");
	} else {
		rtpproxy_manage("cor");
	}
#!endif

	if (is_request()) {
		if (!has_totag()) {
			if(t_is_branch_route()) {
				add_rr_param(";nat=yes");
			}
		}
	}
	if (is_reply()) {
		if(isbflagset(FLB_NATB)) {
			if(is_first_hop())
				set_contact_alias();
		}
	}

	if(isbflagset(FLB_NATB)) {
		# no connect message in a dialog involving NAT traversal
		if (is_request()) {
			if(has_totag()) {
				set_forward_no_connect();
			}
		}
	}
#!endif
	return;
}

# URI update for dialog requests
route[DLGURI] {
#!ifdef WITH_NAT
	if(!isdsturiset()) {
		if (!isflagset(FLT_WS)){
			handle_ruri_alias();
		}else{
			set_contact_alias();
		}
	}
#!endif
	return;
}

# Routing to foreign domains
route[SIPOUT] {
	if (uri==myself) return;

	append_hf("P-Hint: outbound\r\n");
	route(RELAY);
	exit;
}

# PSTN GW routing
route[PSTN] {
#!ifdef WITH_PSTN
	# check if PSTN GW IP is defined
	if (strempty($sel(cfg_get.pstn.gw_ip))) {
		###xlog("SCRIPT: PSTN routing enabled but pstn.gw_ip not defined\n");
		return;
	}

	# route to PSTN dialed numbers starting with '+' or '00'
	#     (international format)
	# - update the condition to match your dialing rules for PSTN routing
	if(!($rU=~"^(\+|00)[1-9][0-9]{3,20}$")) return;

	# only local users allowed to call
	if(from_uri!=myself) {
		sl_send_reply("403", "Not Allowed");
		exit;
	}

	# normalize target number for pstn gateway
	# - convert leading 00 to +
	if (starts_with("$rU", "00")) {
		strip(2);
		prefix("+");
	}

	if (strempty($sel(cfg_get.pstn.gw_port))) {
		$ru = "sip:" + $rU + "@" + $sel(cfg_get.pstn.gw_ip);
	} else {
		$ru = "sip:" + $rU + "@" + $sel(cfg_get.pstn.gw_ip) + ":"
					+ $sel(cfg_get.pstn.gw_port);
	}

	route(RELAY);
	exit;
#!endif

	return;
}

# JSONRPC over HTTP(S) routing
#!ifdef WITH_JSONRPC
#event_route[xhttp:request] {
#	set_reply_close();
#	set_reply_no_connect();
#	if(src_ip!=127.0.0.1) {
#		xhttp_reply("403", "Forbidden", "text/html",
#				"<html><body>Not allowed from $si</body></html>");
#		exit;
#	}
#	if ($hu =~ "^/RPC") {
#		jsonrpc_dispatch();
#		exit;
#	}
#
#	xhttp_reply("200", "OK", "text/html",
#				"<html><body>Wrong URL $hu</body></html>");
#   exit;
#}
#!endif
event_route[xhttp:request] {
        set_reply_close();
        set_reply_no_connect();

        if ($Rp != 80
#!ifdef WITH_TLS
            && $Rp != 443
	&& $Rp != KamailioAPI
        && $Rp != WEBSOCKETPORT
#!endif
        ) {

                xlog("L_WARN", "HTTP request received on $Rp\n");
                xhttp_reply("403", "Forbidden", "", "");
                exit;
        }

        if ($hdr(Upgrade)=~"websocket"
                        && $hdr(Connection)=~"Upgrade"
                        && $rm=~"GET") {

                # Validate Host - make sure the client is using the correct
                # alias for WebSockets
                if ($hdr(Host) == $null || !($hdr(Host) =~ "(^u[0-9]{9}\.ocil\.omnitelecom\.com:WEBSOCKETPORT)$")) {
                        xlog("L_WARN", "Bad websocket request Bad host [domain=$hdr(Host))\n");
                        xhttp_reply("403", "Forbidden", "", "");
                        exit;
                }

                # Optional... perform HTTP authentication

                # ws_handle_handshake() exits (no further configuration file
                # processing of the request) when complete in case of failure.
                if (ws_handle_handshake())
                {
                        # Optional... cache some information about the
                        # successful connection
                        exit;
                }
        }

	if ($hu =~ "newDomain=u[0-9]{9}\.ocil\.omnitelecom\.com$" && $Rp == KamailioAPI){
		$var(domain)=$(hu{s.select,-1,=});
                xlog("L_WARN", "I got a new request $hu to add domain $var(domain)\n");
		exec_cmd("sudo /usr/local/kamailio-1/etc/kamailio/new_domain.sh '$var(domain)'");
                sql_query("pgc", "select domain from omni_domains where domain = '$var(domain)';", "result_sql");
                if ($dbr(result_sql=>[0,0]) != 0) {
                        xhttp_reply("200", "Domain '$var(domain)' is enabled", "", "");
                        xlog("L_WARN", "Domain $var(domain) is added or already existed\n");
                }else{
                        xlog("L_WARN", "Error adding domain $var(domain)\n");
                        xhttp_reply("500", "Domain '$var(domain)' is not enabled", "", "");
                }
		exit;
        }
        xhttp_reply("404", "Not found", "", "");
}
# Routing to voicemail server
route[TOVOICEMAIL] {
#!ifdef WITH_VOICEMAIL
	if(!is_method("INVITE|SUBSCRIBE")) return;

	# check if VoiceMail server IP is defined
	if (strempty($sel(cfg_get.voicemail.srv_ip))) {
		###xlog("SCRIPT: VoiceMail routing enabled but IP not defined\n");
		return;
	}
	if(is_method("INVITE")) {
		if($avp(oexten)==$null) return;

		$ru = "sip:" + $avp(oexten) + "@" + $sel(cfg_get.voicemail.srv_ip)
				+ ":" + $sel(cfg_get.voicemail.srv_port);
	} else {
		if($rU==$null) return;

		$ru = "sip:" + $rU + "@" + $sel(cfg_get.voicemail.srv_ip)
				+ ":" + $sel(cfg_get.voicemail.srv_port);
	}
	route(RELAY);
	exit;
#!endif

	return;
}

# Manage outgoing branches
branch_route[MANAGE_BRANCH] {
	###xlog("new branch [$T_branch_idx] to $ru\n");
	route(NATMANAGE);
}

# Manage incoming replies
reply_route {
	if(!sanity_check("17604", "6")) {
		###xlog("Malformed SIP response from $si:$sp\n");
		drop;
	}
}

# Manage incoming replies in transaction context
onreply_route[MANAGE_REPLY] {
	###xlog("incoming reply\n");
	if(status=~"[12][0-9][0-9]") {
		route(NATMANAGE);
	}
}

# Manage failure routing cases
failure_route[MANAGE_FAILURE] {
	route(NATMANAGE);

	if (t_is_canceled()) exit;

#!ifdef WITH_BLOCK3XX
	# block call redirect based on 3xx replies.
	if (t_check_status("3[0-9][0-9]")) {
		t_reply("404","Not found");
		exit;
	}
#!endif

#!ifdef WITH_BLOCK401407
	# block call redirect based on 401, 407 replies.
	if (t_check_status("401|407")) {
		t_reply("404","Not found");
		exit;
	}
#!endif

#!ifdef WITH_VOICEMAIL
	# serial forking
	# - route to voicemail on busy or no answer (timeout)
	if (t_check_status("486|408")) {
		$du = $null;
		route(TOVOICEMAIL);
		exit;
	}
#!endif
}

event_route[dispatcher:dst-down] {
        exec_avp("sudo /usr/local/kamailio-1/etc/kamailio/checkPrimary.sh", "$avp(isPrimary)");
        if( $avp(isPrimary) != "true") {
                xlog("L_WARN", "FS server is down in secondary kamailio. Only local action... [Type=$rm ServerIP=$ru]\n");
        }else{
                xlog("L_WARN", "FS server is down in Primary kamailio. Updating DB... [Type=$rm ServerIP=$ru]\n");
		sql_query("pgc", "update dispatcher set status='DOWN',flags='9' where destination = '$ru' and setid = '2'", "result_sql");
		sql_query("pgc", "select count(*) from dispatcher d inner join omni_domains o on o.setid = d.setid where d.destination = '$ru' and d.priority = '2' and d.status='';", "result_sql");
                $var(effected) = $dbr(result_sql=>[0,0]);
		sql_query("pgc", "update dispatcher set status='DOWN',flags='1' where (status='' or status is null) and priority > 1  and destination = '$ru';", "result_sql");
		if ($sqlrows(pgc)>0) {
			sql_query("pgc", "select d.description, count(o.id) FILTER (WHERE d.priority = '2') as primary, count(o.id) FILTER (WHERE d.priority = '1') as backup from dispatcher d left join omni_domains o on o.setid = d.setid where d.destination = '$ru' group by d.description;", "result_sql");
			xlog("L_WARN", "FS server '$dbr(result_sql=>[0,0])' is down in Primary kamailio, it have '$dbr(result_sql=>[0,1])' domains set as primary '$var(effected)' used it, there are '$dbr(result_sql=>[0,2])' domains set as secondary\n");
	                exec_dset("sudo /usr/local/kamailio-1/etc/kamailio/emailNotify.py '$dbr(result_sql=>[0,0])' '$dbr(result_sql=>[0,1])' '$dbr(result_sql=>[0,2])' '$var(effected)'");
		        exec_dset("sudo /etc/nginx/CreateDomains.sh sync");
		}else{
			xlog("L_WARN", "FS server is down and no domain used it as primary [Type=$rm ServerIP=$ru]\n");
		}
	}
}
event_route[dispatcher:dst-up] {
	exec_avp("sudo /usr/local/kamailio-1/etc/kamailio/checkPrimary.sh", "$avp(isPrimary)");
        if( $avp(isPrimary) != "true") {
                xlog("L_WARN", "FS server is up in secondary kamailio. Only local action... [Type=$rm ServerIP=$ru]\n");
        }else{
                xlog("L_WARN", "FS server is up in Primary kamailio. Updating DB... [Type=$rm ServerIP=$ru]\n");
                sql_query("pgc", "update dispatcher set status='',flags='8' where destination = '$ru' and setid = '2'");
        }
}
